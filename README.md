# pg-id: generates random-looking never repeating primary key ids and more

This library contains PostgreSQL functions which generate bigint ids having the
following format:

```
EssssRRRRRRRRRRRRRR
 ^   ^^^^^^^^^^^^^^
 4   14
```

Also, `id_gen_uuid()` generates UUIDs looking like:

```
EssssRRR-RRRR-4RRR-NRRR-RRRRRRRRRRRR
```

Here,

- "E" is an "environment number" aka "cluster number" (e.g. denoting dev, test,
  staging, production, or different production regions like us-east-1, us-west-2
  etc.). The range of the 1st digit in E must be 1..7. The current environment
  number (aka cluster number) should be returned by function `id_env_no()`: you
  need to create it beforehand in the schema where you install the library (or,
  alternatively, pass it in `DB_ID_ENV_NO` environment variable before
  installing).
- "ssss" is a 4-digit "microshard number". The range is 0..9999 by default. The
  current value of the microshard should be returned by function
  `id_shard_no()`: you need to create it beforehand in the schema where you
  install the library (or, alternatively, the schema name should end with that
  number; then, the library will auto-infer the shard number from it).
- "RRRRRRRRRRRRRR" is a value which is unique within the chosen "environment
  number" and "microshard number". Depending on the function used, it is either
  a randomly-looking number (for `id_gen()` and `id_gen_uuid()`), a number based
  on the current timestamp (for `id_gen_timestampic()`) or just an
  auto-incrementing number (for `id_gen_monotonic()`).

You can customize the length of "E", "ssss" and "RRRRRRRRRRRRRR" sequences in
your `pg-id.config.sql` file, see below.


## Installation

First, copy `pg-id.config.sql.example` to `pg-id.config.sql` in the root of your
app and update `CONST_MUL`, `CONST_SUM` and `CONST_MOD` with some random numbers
that only you know. Those numbers will play the role of crypto constants which
will not allow people to easily guess the pattern of ids generated by
`id_gen()`.

```sql
-- Define the format of id (variadic part is 14 decimal positions, 46 bits).
-- * EssssRRRRR... (E: 1..7, ssss: 0000...9999, R: 14 decimal positions)
-- * 2^63 = 9_2233_72036854775808, so we have 19 decimal positions in total
\set CONST_ENV_MUL 10
\set CONST_SHARD_MUL 10000
\set CONST_RND_MUL 100000000000000

--
-- The values for id_gen_timestampic().
--
\set CONST_RND_TS_MUL 1000000000
\set CONST_RND_TS_START 1262304000

--
-- The values for id_gen(): all other methods don't use them. Based on
-- https://en.wikipedia.org/wiki/Feistel_cipher
--
-- Once installed, NEVER change these values, or the database will blow up!!!
--
\set CONST_RND_BITS 46
-- Crypto-constants for random looking ids: see id_gen(). The values below are
-- very secret. Don't mess, don't change!
\set CONST_MUL 10000007141763
\set CONST_SUM 10000003795571
\set CONST_MOD 10000009458232
```

Then run in psql console:

```sql
-- Selects the schema you want to install the library to.
SET search_path TO your_schema_1234;

-- Optional: if you don't want to pass DB_ID_ENV_NO environment variable,
-- create this configuration function manually.
--CREATE OR REPLACE FUNCTION id_env_no() RETURNS integer LANGUAGE sql
--  SET search_path FROM CURRENT AS 'SELECT 1';

-- Optional: if your schema name doesn't end up with a microshard number,
-- create this configuration function manually.
--CREATE OR REPLACE FUNCTION id_shard_no() RETURNS integer LANGUAGE sql
--  SET search_path FROM CURRENT AS 'SELECT 123';

-- Install the library to the current schema. It will load crypto constants
-- from pg-id.config.sql, get the environment number from DB_ID_ENV_NO
-- environment variable and infer microshard number from the numeric
-- suffix of the current schema.
\ir .../pg-id-up.sql
```

The `pg-id-up.sql` installation script will search for `pg-id.config.sql` file
in the parent folders (it will fail if the file is not found).

By default, environment number is read from `DB_ID_ENV_NO` shell env variable.
This way, you can assign it to e.g. 1 for development, 2 for staging and 3 for
production environments. If for some reason you don't want this behavior, just
define `id_env_no()` function manually.

Also, unless you created `id_shard_no()` manually, the installation script will
try to infer the microshard number from the current schema name suffix. E.g. if
your schemas are named `sh0000`, `sh0042`, `your_schema_1234` etc., then you're
good with that default behavior.


## id_gen()

Generates next globally-unique randomly-looking id. The main idea is to not let
external people infer the rate at which the ids are generated, even when they
look at some ids sample.

The function implicitly uses `id_seq` sequence to get the information about the
next available number, and then uses Feistel cipher to generate a
randomly-looking non-repeating id based of it.

Examples of ids generated (underscores are just for illustration):

- `2_0000_17217633124378`: "environment 2, shard 0, number 17217633124378"
- `1_0238_17493700363834`: "environment 1, shard 238, number 17493700363834"


## id_gen_timestampic()

Similar to `id_gen()`, but instead of generating randomly looking ids, prepends
the "sequence" part of the id with the current timestamp (actually, the number
of seconds since 2010-01-01 UTC). The function reserves up to 5 decimal digits
for the number part of the id, so within each second, up to 100k unique ids can
be generated.

The function implicitly uses `id_seq_timestampic` sequence to get the
information about the next available number.

The benefit of this function is performance: increasing ids are more friendly to
heavy INSERTs since they maximize the chance for btree index to reuse the newly
created leaf pages. At the same time, having timestamp in the prefix doesn't
allow to infer the number of objects existing in the database so far.

Example of id generated (underscores are just for illustration):

- `2_0001_435044939_00029`: "environment 2, shard 1, seconds 435044939, num 29"


## id_gen_monotonic()

The simplest and fastest function among the above: generates next
globally-unique monotonic id, without using any timestamps as a prefix.
Monotonic ids are more friendly to heavy INSERTs since they maximize the chance
for btree index to reuse the newly created leaf pages.

The function implicitly uses `id_seq_monotonic` sequence to get the information
about the next available number.

Example of id generated (underscores are just for illustration):

- `2_0001_00000000000003`: "environment 2, shard 1, number 3"

The downside is that the ids of this format basically expose the number of
unique objects which were created in the database so far.


## id_gen_uuid()

An example UUID generated by that function:

```
10246RRR-RRRR-4RRR-NRRR-RRRRRRRRRRRR
```

Here, 1 is environment number (e.g. production) and 0246 is microshard number.

Basically, the function uses PostgreSQL built-in
[gen_random_uuid()](https://www.postgresql.org/docs/current/functions-uuid.html),
but replaces the first digits with environment and microshard numbers. This
trick doesn't cut too much of the UUID's entropy, but allows to use UUIDs in
microsharded environment.

